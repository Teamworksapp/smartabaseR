#' @title
#' Export event data
#'
#' @description
#' `sb_get_event()` exports data from a Smartabase event form using
#' the Smartabase API. It requires the user to input a valid Smartabase
#' event form name, date range, url and credentials.
#'
#' For more details see the help vignette:
#' \code{vignette("exporting-data")}
#'
#' @section date_range:
#' `sb_get_event()` returns events that occur between a start date and an end
#' date. We must supply these dates via the `date_range` argument which
#' accepts a vector of length two. The first element is the start date
#' and the second element is the end date. The dates must be character types
#' represented in "dd/mm/YYYY" format.
#'
#' Alternatively you can use the [sb_date_range()] function to
#' generate the date range dynamically. See [sb_date_range()] for more
#' details.
#'
#' @section filter:
#' There are also a range extra filters than can be supplied to the `filter`
#' argument, including user filters, data filters and filters for getting the
#' most recent events. In order to reduce argument clutter in
#' `sb_get_event()`, all optional filters must be generated by the
#' [sb_get_event_filter()] function.
#'
#' @section time_range:
#' As well as requiring a date range from which to export events,
#' `sb_get_event()` also optionally allows specification of a valid time range.
#' Similar to `date_range`, `time_range` is a length 2 character vector. The
#' first element is the start time and the second element is the end time. The
#' times must be character types represented in "h:mm am/pm" format. Defaults
#' to c("12:00 am", "11:59 pm").
#'
#' @section option:
#' There are also a range of extra options than can be supplied to the `option`
#' argument, including options for downloading attachments and suppressing
#' messages to the console, among others.  In order to reduce argument clutter
#' in `sb_get_event()`, all options must be generated by the
#' [sb_get_event_option()] function.
#'
#' @param form Name of Smartabase event form
#' @param date_range Character vector of length two containing valid start_date
#' end_date (dd/mm/YYYY) character values
#' @param url Smartabase url e.g. "example.smartabase.com/site"
#' @param username Smartabase username
#' @param password Smartabase password
#' @param ... These dots are for future extensions and must be empty
#' @param filter More filters accessible via [sb_get_event_filter()] object
#' @param option More options accessible via [sb_get_event_option()] object
#' @param time_range Vector of length two containing a valid start_time and
#' and end_time (h:mm am/pm) character values. Defaults to
#' `c("12:00 am", "11:59 pm)`.
#'
#' @returns A tibble containing Smartabase event data
#' @export
#'
#' @examples
#' \dontrun{
#' # Get one week of wellness data from 'example.smartabase.com/site':
#' sb_get_event(
#'   form = "Daily Wellness",
#'   date_range = c("15/04/2023", "22/04/2023"),
#'   url = "example.smartabase.com/site",
#'   username = "example.user",
#'   password = "example_password"
#' )
#'
#' # Now retrieve data for the last 7 days using [sb_date_range()],
#' # then, using [sb_get_event_filter()], filter for users in the Smartabase
#' # group "example_group" and only return values where "example_field" is
#' # greater than 1. Also download any attachments if they're available using
#' # [sb_get_event_option()].
#' sb_get_event(
#'   form = "Daily Wellness",
#'   date_range = sb_date_range("7", "days"),
#'   url = "example.smartabase.com/site",
#'   username = "example.user",
#'   password = "example_password",
#'   filter = sb_get_event_filter(
#'     user_key = "group",
#'     user_value = "example_group",
#'     data_key = "example_field",
#'     data_value = 1,
#'     data_condition = "greater_than"
#'   ),
#'   option = sb_get_event_option(
#'     download_attachment = TRUE
#'   )
#' )
#' }
#'
#' @family export functions
#' @seealso
#' [sb_get_profile()] for profile data.
#' [sb_get_user()] for user data.
#' [sb_sync_event()] to synchronise with an event form.
sb_get_event <- function(
    form,
    date_range,
    url,
    username,
    password,
    ...,
    filter = sb_get_event_filter(),
    option = sb_get_event_option(),
    time_range = c("12:00 am", "11:59 pm")
) {
  rlang::check_dots_used()
  env <- rlang::current_env()
  .check_export_class(filter, option, env)
  filter$data_filter <- .insert_form_data_filter(form, filter$data_filter)
  if (!is.null(filter$data_filter)) {
    endpoint <- "filteredeventsearch"
  } else {
    endpoint <- "eventsearch"
  }
  if (is.null(filter$user_key) || is.null(filter$user_value)) {
    lifecycle::deprecate_warn(
      "1.0.0",
      what = "sb_get_event_filter(user_key = 'will be required')",
      details = "In the next major release, user_key and user_value \\
      must be supplied to the filter argument via sb_get_event_filter()."
    )
  }

  arg <- list(
    form = form,
    url = .validate_url(url),
    username = username,
    password = password,
    date_range = date_range,
    time_range = time_range,
    filter = filter,
    option = option,
    endpoint = endpoint,
    endpoint_type = "event",
    current_env = env,
    pull_smartabase = FALSE,
    ...
  )
  .validate_filter_user_key(arg)
  .validate_date_time_range(arg)
  arg$start_date_clean <- format(lubridate::dmy(date_range[[1]]), "%b %d %Y")
  arg$end_date_clean <- format(lubridate::dmy(date_range[[2]]), "%b %d %Y")

  if (!is.null(arg$dev_mode)) {
    if (isTRUE(arg$dev_mode)) {
      return(arg)
    }
  }

  if (isTRUE(arg$option$interactive_mode)) {
    export_progress_id <- .generate_export_progress_msg(arg)
    set_progress_id("export_progress_id", export_progress_id)
  }
  .export_handler(arg)
}


#' @title
#' Export modified event data since the last synchronisation time
#'
#' @description
#' `sb_sync_event()` exports data from a Smartabase event form using the
#' Smartabase API. The user must supply a timestamp in unix format (i.e.
#' milliseconds since 1970-01-01) and `sb_sync_event()` will return event data
#' that has been inserted or updated since that time.
#'
#' `sb_sync_event()` also attaches a `new_sync_time` attribute to the returned
#' tibble. This attribute can then be stripped from the tibble and fed into a
#' subsequent call of `sb_sync_event()` via the `last_sync_time` argument.
#'
#' @details
#' A common use case for `smartabaseR` is to help automate certain data
#' wrangling and/or modelling tasks in Smartabase. By running `sb_sync_event()`
#' on a schedule (i.e. a 15 minute cron job), we can write logic that only
#' triggers when newly modified event data is discovered. The idea is to take
#' the `new_sync_time` value returned from `sb_sync_event()` and feed it back
#' into a subsequent call of `sb_sync_event()` via the `last_sync_time`
#' argument.
#'
#' @section Filters:
#' There are also a range extra filters than can be supplied to the `filter`
#' argument. In order to reduce argument clutter in `sb_sync_event()`, all
#' optional filters must be generated by the
#' [sb_sync_event_filter()] function. Please see [sb_sync_event_filter()]
#' for more details.
#'
#' @section Options:
#' There are also a range extra options than can be supplied to the `option`
#' argument. In order to reduce argument clutter in `sb_sync_event()`, all
#' options must be generated by the [sb_sync_event_option()] function. Please
#' see [sb_sync_event_option()] for more details.
#'
#' @param form Name of Smartabase event form
#' @param last_sync_time UNIX time (time in milliseconds since 1970-01-01) as
#' an integer
#' @param url Smartabase url e.g. "example.smartabase.com/site"
#' @param username Smartabase username
#' @param password Smartabase password
#' @param ... These dots are for future extensions and must be empty
#' @param filter More filters accessible via [sb_sync_event_filter()] object
#' @param option More options accessible via [sb_sync_event_option()] object
#'
#' @returns A tibble containing Smartabase event data
#' @export
#'
#' @examples
#' \dontrun{
#' # Get any wellness data that has been modified since Jan 01 2023
#' (1672531200000):
#' new_wellness_data <- sb_sync_event(
#'   form = "Daily Wellness",
#'   last_sync_time = 1672531200000,
#'   url = "example.smartabase.com/site",
#'   username = "example.user",
#'   password = "examplePassword"
#' )
#' }
#'
#' @family export functions
#' @seealso
#' [sb_get_profile()] for profile data.
#' [sb_get_user()] for user data.
#' [sb_sync_event()] to synchronise with an event form.
sb_sync_event <- function(
    form,
    last_sync_time,
    url,
    username,
    password,
    ...,
    filter = sb_sync_event_filter(),
    option = sb_sync_event_option()
) {
  rlang::check_dots_used()
  env <- rlang::current_env()
  .check_export_class(filter, option, env)
  if (is.null(filter$user_key) || is.null(filter$user_value)) {
    lifecycle::deprecate_warn(
      "1.0.0",
      what = "sb_sync_event_filter(user_key = 'will be required')",
      details = "In the next major release, user_key and user_value \\
      must be supplied to the filter argument via sb_sync_event_filter()."
    )
  }

  arg <- list(
    form = form,
    last_sync_time = last_sync_time,
    url = url,
    username = username,
    password = password,
    filter = filter,
    option = option,
    endpoint = "synchronise",
    endpoint_type = "event",
    current_env = env,
    pull_smartabase = FALSE,
    ...
  )
  .validate_filter_user_key(arg)
  arg$url <- .validate_url(url)

  if (!is.null(arg$dev_mode)) {
    if (isTRUE(arg$dev_mode)) {
      return(arg)
    }
  }
  .export_handler(arg)
}


#' @title
#' Export data from a Smartabase profile form
#'
#' @description
#' This function exports data from a Smartabase profile form using the
#' Smartabase API. It requires the user to input a valid Smartabase
#' event form name, url and credentials.
#'
#' For more details see the help vignette:
#' \code{vignette("exporting-data")}
#'
#' @section Filters:
#' There are also a range extra filters than can be supplied to the `filter`
#' argument. In order to reduce argument clutter in `sb_get_profile()`, all
#' optional filters must be generated by the
#' [sb_get_profile_filter()] function. Please see [sb_get_profile_filter()]
#' for more details.
#'
#' @section Options:
#' There are also a range extra options than can be supplied to the `option`
#' argument. In order to reduce argument clutter in `sb_get_profile()`, all
#' options must be generated by the [sb_get_profile_option()] function. Please
#' see [sb_get_profile_option()] for more details.
#'
#' @param form Name of Smartabase profile form
#' @param url Smartabase url e.g. "example.smartabase.com/site"
#' @param username Smartabase username
#' @param password Smartabase password
#' @param ... These dots are for future extensions and must be empty
#' @param filter More filters accessible via [sb_get_profile_filter()]
#' @param option More options accessible via [sb_get_profile_option()]
#'
#' @returns tibble: Smartabase profile data
#' @export
#'
#' @examples
#' \dontrun{
#' # Get profile data from "Athlete Profile" form:
#' sb_get_profile(
#'   form = "Athlete Profile",
#'   url = "example.smartabase.com/site",
#'   username = "example.user",
#'   password = "examplePassword"
#' )
#' }
#'
#' @family export functions
#' @seealso
#' [sb_get_event()]
#' [sb_get_user()]
#' [sb_sync_event()]
sb_get_profile <- function(
    form,
    url,
    username,
    password,
    ...,
    filter = sb_get_profile_filter(),
    option = sb_get_profile_option()) {
  rlang::check_dots_used()
  env <- rlang::current_env()
  .check_export_class(filter, option, env)
  if (is.null(filter$user_key) || is.null(filter$user_value)) {
    lifecycle::deprecate_warn(
      "1.0.0",
      what = "sb_get_profile_filter(user_key = 'will be required')",
      details = "In the next major release, user_key and user_value \\
      must be supplied to the filter argument via sb_get_profile_filter()."
    )
  }

  arg <- list(
    form = form,
    url = url,
    username = username,
    password = password,
    filter = filter,
    option = option,
    endpoint = "profilesearch",
    endpoint_type = "profile",
    current_env = rlang::current_env(),
    pull_smartabase = FALSE,
    ...
  )
  .validate_filter_user_key(arg)
  arg$url <- .validate_url(url)
  if (!is.null(arg$dev_mode)) {
    if (isTRUE(arg$dev_mode)) {
      return(arg)
    }
  }
  .export_handler(arg)
}


#' @title
#' Export Smartabase group data
#'
#' @description
#' This function uses the Smartabase API to export the names of the
#' Smartabase groups that the logged in user has access to.
#'
#' For more details see the help vignette:
#' \code{vignette("helper-functions")}
#'
#' @section Options:
#' There are also a range extra options than can be supplied to the `option`
#' argument. In order to reduce argument clutter in `sb_get_group()`, all
#' options must be generated by the [sb_get_group_option()] function. Please
#' see [sb_get_group_option()] for more details.
#'
#' @param url Smartabase url; e.g. 'example.smartabase.com/site'
#' @param username Smartabase username
#' @param password Smartabase password
#' @param ... These dots are for future extensions and must be empty
#' @param option More options generated by a [sb_get_user_option()] object
#'
#' @returns A tibble containing Smartabase group data
#' @export
#'
#' @examples
#' \dontrun{
#' # Get user ID data:
#' group_data <- sb_get_group(
#'   url = "example.smartabase.com/site",
#'   username = "example.user",
#'   password = "examplePassword"
#' )
#' }
sb_get_group <- function(
    url,
    username,
    password,
    ...,
    option = sb_get_group_option()) {
  rlang::check_dots_used()
  env <- rlang::current_env()
  .check_export_class(filter = NULL, option, env)
  arg <- list(
    url = url,
    username = username,
    password = password,
    option = option,
    endpoint = "listgroups",
    endpoint_type = "group",
    current_env = rlang::current_env(),
    pull_smartabase = FALSE,
    ...
  )

  arg$url <- .validate_url(url)
  .export_handler(arg)
}


#' @title
#' Export Smartabase user data
#'
#' @description
#' `sb_get_user()` exports user data using the Smartabase API. It requires
#' the user to input a valid Smartabase url and valid Smartabase credentials.
#'
#' For more details see the help vignette:
#' \code{vignette("helper-functions")}
#'
#' @section Filters:
#' There are also a range extra filters than can be supplied to the `filter`
#' argument. In order to reduce argument clutter in `sb_get_user()`, all
#' optional filters must be generated by the
#' [sb_get_user_filter()] function. Please see [sb_get_user_filter()]
#' for more details.
#'
#' @section Options:
#' There are also a range extra options than can be supplied to the `option`
#' argument. In order to reduce argument clutter in `sb_get_user()`, all
#' options must be generated by the [sb_get_user_option()] function. Please
#' see [sb_get_user_option()] for more details.
#'
#' @param url Smartabase url; e.g. 'example.smartabase.com/site'
#' @param username Smartabase username
#' @param password Smartabase password
#' @param ... These dots are for future extensions and must be empty
#' @param filter More filters generated by a [sb_get_user_filter()] object
#' @param option More options generated by a [sb_get_user_option()] object
#'
#' @returns A tibble containing Smartabase user data
#' @export
#'
#' @examples
#' \dontrun{
#' # Get user ID data about Jamie Anderson:
#' user_data <- sb_get_user(
#'   url = "example.smartabase.com/site",
#'   username = "example.username",
#'   password = "example_password",
#'   filter = sb_get_event_filter(
#'     user_key = "about",
#'     user_value = "Jamie Anderson"
#'   )
#' )
#'
#' # Return all user columns:
#' user_data <- sb_get_user(
#'   url = "example.smartabase.com/site",
#'   username = "example.username",
#'   password = "example_password",
#'   option = sb_get_user_option(
#'     include_all_cols = TRUE
#'   )
#' )
#' }
#'
#' @family export functions
#' @seealso
#' [sb_get_profile()] for profile data.
#' [sb_get_user()] for user data.
#' [sb_sync_event()] to synchronise with an event form.
sb_get_user <- function(
    url,
    username,
    password,
    ...,
    filter = sb_get_user_filter(),
    option = sb_get_user_option()
) {
  rlang::check_dots_used()
  env <- rlang::current_env()
  .check_export_class(filter, option, env)

  if (!is.null(filter$user_key)) {
    if (filter$user_key == "current_group") {
      endpoint <- "currentgroup"
    } else if (filter$user_key == "group") {
      endpoint <- "groupmembers"
    } else {
      endpoint <- "usersearch"
    }
  } else {
    endpoint <- "usersearch"
  }

  arg <- list(
    url = .validate_url(url),
    username = username,
    password = password,
    filter = filter,
    option = option,
    endpoint = endpoint,
    endpoint_type = "user",
    current_env = env,
    ...
  )
  .validate_filter_user_key(arg)

  if (!is.null(arg$dev_mode)) {
    if (isTRUE(arg$dev_mode)) {
      return(arg)
    }
  }
  .export_handler(arg)
}




#' .get_user_id_for_export_body
#'
#' Populates user ID values for export filter
#'
#' Every call to the Smartabase event export API requires a list of athlete
#' user IDs. This function invokes [sb_get_user()] and caches the results
#'
#' @param arg List of arguments passed from export functions
#'
#' @returns tibble: Smartabase user data
#'
#' @noRd
#'
#' @keywords internal
.get_user_id_for_export_body <- function(arg) {
  relevant_endpoints <- c(
    "eventsearch",
    "filteredeventsearch",
    "profilesearch",
    "synchronise"
  )

  if (!arg$endpoint %in% relevant_endpoints) {
    return()
  }

  if (!is.null(arg$pull_smartabase)) {
    if (isTRUE(arg$pull_smartabase)) {
      filter_fun <- .pull_smartabase_filter
      option_fun <- .pull_smartabase_option
    } else {
      filter_fun <- sb_get_user_filter
      option_fun <- sb_get_user_option
    }
  }

  id_filter_names <- intersect(names(arg$filter), names(filter_fun()))
  id_filters <- arg$filter[names(arg$filter) %in% id_filter_names]
  id_option_names <- intersect(names(arg$option), names(option_fun()))
  id_options <- arg$option[names(arg$option) %in% id_option_names]
  get_id_flag <- TRUE
  if (!is.null(id_options$include_user_data)) {
    if (isFALSE(id_options$include_user_data)) {
      if (!is.null(id_filters$user_key)) {
        if (id_filters$user_key == "user_id") {
          if (!is.null(id_filters$user_value)) {
            get_id_flag <- FALSE
          }
        }
      }
    }
  }

  if (isTRUE(get_id_flag)) {
    id_data <- sb_get_user(
      url = arg$url,
      username = arg$username,
      password = arg$password,
      filter = do.call(filter_fun, id_filters),
      option = do.call(option_fun, id_options)
    ) %>%
      dplyr::select(-c(.data$username, .data$email)) %>%
      dplyr::distinct()
  } else {
    id_data <- tibble::tibble(user_id = id_filters$user_value)
  }
  id_data
}
