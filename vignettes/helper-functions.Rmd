---
title: "Helper Functions"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
editor_options:
  chunk_output_type: console
vignette: >
  %\VignetteIndexEntry{Helper Functions}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

If you haven't already, please read the `getting-started` vignette before proceeding: `vignette("getting-started")`.

`smartabaseR` contains several helper functions that are called within other exported functions. The two main ones are `sb_get_user()` and `sb_get_group()`.

## sb_get_user()

`sb_get_user()` leverages the Smartabase API (v1) to get user data out of Smartabase and into your R session.

`sb_get_user()` returns the user IDs, emails and usernames for specific Smartabase users. Set the `include_uuid` option to `TRUE` to return each user's Smartabase UUID, which is an ID that can be set on the Smartabase admin site (as opposed to `user_id`, which is automatically generated by Smartabase). 

Similar to `sb_get_event()`, you can optionally supply the `user_key` and `user_value` options. Note: if these arguments are left empty, then all user data your account has access to will be returned.

Why is `sb_get_event()` useful? Recall that the Smartabase API requires athletes' user IDs when importing into Smartabase with `sb_insert_event()` etc. (see `vignette("importing-data")`). `sb_get_user()` is just one way to find your athletes' user IDs for use with `sb_insert_event()` and the rest of the import functions.

### User filtering

`user_key` and `user_value` allow you to get event/profile data for specific Smartabase users.

`user_key` represents the user identification method: 'about', 'user_id', 'username' or 'email'. 

**about**

All `filter` values must be generated by the relevant helper function. So, if we're using `sb_get_user()` to export user data only for the athlete `Jamie Anderson`, we would need to use `sb_get_user_filter()` along with the `user_key` and `user_value` options:

```{r filter_example, eval = FALSE}
sb_get_user(
  url = "example.smartabase.com/site",
  username = "example.username",
  password = "example_password",
  filter = sb_get_event_filter(
    user_key = "about",
    user_value = "Jamie Anderson"
  )
)
```

If `user_key = "about"`, `data_value` accepts *full names*.

See `vignette("exporting-data")` for a breakdown of the other possible `user_key` arguments. 

## sb_get_group() {#get_group}

`sb_get_group()` returns a list of Smartabase groups available to your account. It's arguments are `username`, `password` and `url`.

```{r, get_group, eval = FALSE}
get_group(
  url = "example.smartabase.com/site",
  username = "example.username",
  password = "example_password"
)
```

```{r get_group_print, echo = FALSE}
groups_df <- dplyr::tibble(
  Group = c("All Users", "First Team", "Reserves")
)

groups_df
```


## sb_select_metadata() 

Once data has been exported from Smartabase, it is often desirable to retain the metadata variables (e.g. about, start_time etc.) in the data frame before importing back to Smartabase. Rather than having to repeatedly write out the vector of metadata variables you want to retain (e.g. `{r, eval = FALSE} example_df %>% select(c("about", "user_id", "start_date", "end_date", "start_time", "end_time"), everything())`), this helper function will look for any metadata variables present in a data frame and return them.

```{r get_metadata_names_example, eval = FALSE}
example_df <- dplyr::tibble(
  about = c("Jamie Anderson", "Charlie Thompson"),
  start_date = c("14/02/2023", "14/02/2023"),
  form = "Hydration",
  `Body Weight pre training` = round(runif(2, 82, 92), 0),
  `Body Weight post training` = round(runif(2, 82, 92), 0),
  `Urine Colour` = round(runif(2, 1, 8), 0),
  end_date = c("14/02/2023", "14/02/2023")
)

example_df %>% dplyr::select(sb_select_metadata(.))
```
